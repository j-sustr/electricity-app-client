/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IArchiveClient {
    getQuantities(groupId: string | undefined, arch: number | undefined): Observable<QuantitiesDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ArchiveClient implements IArchiveClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getQuantities(groupId: string | undefined, arch: number | undefined): Observable<QuantitiesDto> {
        let url_ = this.baseUrl + "/api/Archive/quantities?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (arch === null)
            throw new Error("The parameter 'arch' cannot be null.");
        else if (arch !== undefined)
            url_ += "arch=" + encodeURIComponent("" + arch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuantities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuantities(<any>response_);
                } catch (e) {
                    return <Observable<QuantitiesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuantitiesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuantities(response: HttpResponseBase): Observable<QuantitiesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuantitiesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuantitiesDto>(<any>null);
    }
}

export interface IAuthClient {
    login(username: string | null | undefined, password: string | null | undefined): Observable<UserDto>;
    logout(): Observable<FileResponse>;
    getCurrentUser(): Observable<UserDto | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(username: string | null | undefined, password: string | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/Auth/login?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    logout(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getCurrentUser(): Observable<UserDto | null> {
        let url_ = this.baseUrl + "/api/Auth/current-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<UserDto | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto | null>(<any>null);
    }
}

export interface ICostsClient {
    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, maxGroups: number | null | undefined): Observable<CostsOverviewDto>;
    getDetail(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined): Observable<CostsDetailDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CostsClient implements ICostsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, maxGroups: number | null | undefined): Observable<CostsOverviewDto> {
        let url_ = this.baseUrl + "/api/Costs/overview?";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (maxGroups !== undefined && maxGroups !== null)
            url_ += "MaxGroups=" + encodeURIComponent("" + maxGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOverview(<any>response_);
                } catch (e) {
                    return <Observable<CostsOverviewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CostsOverviewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOverview(response: HttpResponseBase): Observable<CostsOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostsOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostsOverviewDto>(<any>null);
    }

    getDetail(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined): Observable<CostsDetailDto> {
        let url_ = this.baseUrl + "/api/Costs/detail?";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<CostsDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CostsDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CostsDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostsDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostsDetailDto>(<any>null);
    }
}

export interface IDataSourceClient {
    getTenant(): Observable<FileResponse>;
    setTenant(identifier: string | null | undefined): Observable<FileResponse>;
    open(command: OpenDataSourceCommand): Observable<DataSourceInfoDto>;
    getInfo(): Observable<DataSourceInfoDto>;
    clearCache(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class DataSourceClient implements IDataSourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTenant(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataSource/tenant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenant(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenant(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    setTenant(identifier: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataSource/tenant?";
        if (identifier !== undefined && identifier !== null)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTenant(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetTenant(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    open(command: OpenDataSourceCommand): Observable<DataSourceInfoDto> {
        let url_ = this.baseUrl + "/api/DataSource/open";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpen(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processOpen(response: HttpResponseBase): Observable<DataSourceInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceInfoDto>(<any>null);
    }

    getInfo(): Observable<DataSourceInfoDto> {
        let url_ = this.baseUrl + "/api/DataSource/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(<any>response_);
                } catch (e) {
                    return <Observable<DataSourceInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataSourceInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfo(response: HttpResponseBase): Observable<DataSourceInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataSourceInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataSourceInfoDto>(<any>null);
    }

    clearCache(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataSource/cache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IDBDataSourceClient {
    getRecords(): Observable<SmpMeasNameDBDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class DBDataSourceClient implements IDBDataSourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRecords(): Observable<SmpMeasNameDBDto[]> {
        let url_ = this.baseUrl + "/api/DBDataSource/records";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecords(<any>response_);
                } catch (e) {
                    return <Observable<SmpMeasNameDBDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SmpMeasNameDBDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecords(response: HttpResponseBase): Observable<SmpMeasNameDBDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SmpMeasNameDBDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SmpMeasNameDBDto[]>(<any>null);
    }
}

export interface IFileClient {
    upload(formFile: FileParameter | null | undefined): Observable<string>;
    delete(fileName: string | null): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class FileClient implements IFileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    upload(formFile: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/File";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    delete(fileName: string | null): Observable<string> {
        let url_ = this.baseUrl + "/api/File/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IGroupsClient {
    getUserGroupInfoTree(): Observable<GroupInfoDto>;
    getUserRecordGroupInfos(): Observable<GroupInfoDto[]>;
    getGroupInfo(id: string | null | undefined, recurseSubgroups: boolean | undefined, archs: number[] | null | undefined, infoType: ArchiveInfoType | undefined, range_DateMin: Date | undefined, range_DateMax: Date | undefined, iDisGroup: boolean | undefined): Observable<GroupInfoDto>;
}

@Injectable({
    providedIn: 'root'
})
export class GroupsClient implements IGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserGroupInfoTree(): Observable<GroupInfoDto> {
        let url_ = this.baseUrl + "/api/Groups/user-group-info-tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroupInfoTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroupInfoTree(<any>response_);
                } catch (e) {
                    return <Observable<GroupInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroupInfoTree(response: HttpResponseBase): Observable<GroupInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupInfoDto>(<any>null);
    }

    getUserRecordGroupInfos(): Observable<GroupInfoDto[]> {
        let url_ = this.baseUrl + "/api/Groups/user-record-group-infos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRecordGroupInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRecordGroupInfos(<any>response_);
                } catch (e) {
                    return <Observable<GroupInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserRecordGroupInfos(response: HttpResponseBase): Observable<GroupInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupInfoDto[]>(<any>null);
    }

    getGroupInfo(id: string | null | undefined, recurseSubgroups: boolean | undefined, archs: number[] | null | undefined, infoType: ArchiveInfoType | undefined, range_DateMin: Date | undefined, range_DateMax: Date | undefined, iDisGroup: boolean | undefined): Observable<GroupInfoDto> {
        let url_ = this.baseUrl + "/api/Groups/info?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (recurseSubgroups === null)
            throw new Error("The parameter 'recurseSubgroups' cannot be null.");
        else if (recurseSubgroups !== undefined)
            url_ += "RecurseSubgroups=" + encodeURIComponent("" + recurseSubgroups) + "&";
        if (archs !== undefined && archs !== null)
            archs && archs.forEach(item => { url_ += "Archs=" + encodeURIComponent("" + item) + "&"; });
        if (infoType === null)
            throw new Error("The parameter 'infoType' cannot be null.");
        else if (infoType !== undefined)
            url_ += "infoType=" + encodeURIComponent("" + infoType) + "&";
        if (range_DateMin === null)
            throw new Error("The parameter 'range_DateMin' cannot be null.");
        else if (range_DateMin !== undefined)
            url_ += "range.DateMin=" + encodeURIComponent(range_DateMin ? "" + range_DateMin.toJSON() : "") + "&";
        if (range_DateMax === null)
            throw new Error("The parameter 'range_DateMax' cannot be null.");
        else if (range_DateMax !== undefined)
            url_ += "range.DateMax=" + encodeURIComponent(range_DateMax ? "" + range_DateMax.toJSON() : "") + "&";
        if (iDisGroup === null)
            throw new Error("The parameter 'iDisGroup' cannot be null.");
        else if (iDisGroup !== undefined)
            url_ += "IDisGroup=" + encodeURIComponent("" + iDisGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupInfo(<any>response_);
                } catch (e) {
                    return <Observable<GroupInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupInfo(response: HttpResponseBase): Observable<GroupInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupInfoDto>(<any>null);
    }
}

export interface IPeakDemandClient {
    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, maxGroups: number | null | undefined): Observable<PeakDemandOverviewDto>;
    getDetail(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, aggregation: DemandAggregation | undefined): Observable<PeakDemandDetailDto>;
}

@Injectable({
    providedIn: 'root'
})
export class PeakDemandClient implements IPeakDemandClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, maxGroups: number | null | undefined): Observable<PeakDemandOverviewDto> {
        let url_ = this.baseUrl + "/api/PeakDemand/overview?";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (maxGroups !== undefined && maxGroups !== null)
            url_ += "MaxGroups=" + encodeURIComponent("" + maxGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOverview(<any>response_);
                } catch (e) {
                    return <Observable<PeakDemandOverviewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PeakDemandOverviewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOverview(response: HttpResponseBase): Observable<PeakDemandOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeakDemandOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PeakDemandOverviewDto>(<any>null);
    }

    getDetail(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, aggregation: DemandAggregation | undefined): Observable<PeakDemandDetailDto> {
        let url_ = this.baseUrl + "/api/PeakDemand/detail?";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (aggregation === null)
            throw new Error("The parameter 'aggregation' cannot be null.");
        else if (aggregation !== undefined)
            url_ += "Aggregation=" + encodeURIComponent("" + aggregation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<PeakDemandDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PeakDemandDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<PeakDemandDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeakDemandDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PeakDemandDetailDto>(<any>null);
    }
}

export interface IPowerFactorClient {
    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, maxGroups: number | null | undefined): Observable<PowerFactorOverviewDto>;
    getDistribution(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, phases_Main: boolean | null | undefined, phases_L1: boolean | null | undefined, phases_L2: boolean | null | undefined, phases_L3: boolean | null | undefined): Observable<PowerFactorDistributionDto>;
}

@Injectable({
    providedIn: 'root'
})
export class PowerFactorClient implements IPowerFactorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, maxGroups: number | null | undefined): Observable<PowerFactorOverviewDto> {
        let url_ = this.baseUrl + "/api/PowerFactor/overview?";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (maxGroups !== undefined && maxGroups !== null)
            url_ += "MaxGroups=" + encodeURIComponent("" + maxGroups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOverview(<any>response_);
                } catch (e) {
                    return <Observable<PowerFactorOverviewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerFactorOverviewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOverview(response: HttpResponseBase): Observable<PowerFactorOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PowerFactorOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerFactorOverviewDto>(<any>null);
    }

    getDistribution(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, phases_Main: boolean | null | undefined, phases_L1: boolean | null | undefined, phases_L2: boolean | null | undefined, phases_L3: boolean | null | undefined): Observable<PowerFactorDistributionDto> {
        let url_ = this.baseUrl + "/api/PowerFactor/distribution?";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (phases_Main !== undefined && phases_Main !== null)
            url_ += "Phases.Main=" + encodeURIComponent("" + phases_Main) + "&";
        if (phases_L1 !== undefined && phases_L1 !== null)
            url_ += "Phases.L1=" + encodeURIComponent("" + phases_L1) + "&";
        if (phases_L2 !== undefined && phases_L2 !== null)
            url_ += "Phases.L2=" + encodeURIComponent("" + phases_L2) + "&";
        if (phases_L3 !== undefined && phases_L3 !== null)
            url_ += "Phases.L3=" + encodeURIComponent("" + phases_L3) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistribution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistribution(<any>response_);
                } catch (e) {
                    return <Observable<PowerFactorDistributionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerFactorDistributionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDistribution(response: HttpResponseBase): Observable<PowerFactorDistributionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PowerFactorDistributionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerFactorDistributionDto>(<any>null);
    }
}

export class QuantitiesDto implements IQuantitiesDto {
    list?: QuantityDto[] | null;

    constructor(data?: IQuantitiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(QuantityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuantitiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuantitiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuantitiesDto {
    list?: QuantityDto[] | null;
}

export class QuantityDto implements IQuantityDto {
    propName?: string | null;
    unit?: string | null;
    returnType?: string | null;
    prop?: string | null;
    value?: any | null;

    constructor(data?: IQuantityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propName = _data["propName"] !== undefined ? _data["propName"] : <any>null;
            this.unit = _data["unit"] !== undefined ? _data["unit"] : <any>null;
            this.returnType = _data["returnType"] !== undefined ? _data["returnType"] : <any>null;
            this.prop = _data["prop"] !== undefined ? _data["prop"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): QuantityDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuantityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propName"] = this.propName !== undefined ? this.propName : <any>null;
        data["unit"] = this.unit !== undefined ? this.unit : <any>null;
        data["returnType"] = this.returnType !== undefined ? this.returnType : <any>null;
        data["prop"] = this.prop !== undefined ? this.prop : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IQuantityDto {
    propName?: string | null;
    unit?: string | null;
    returnType?: string | null;
    prop?: string | null;
    value?: any | null;
}

export class UserDto implements IUserDto {
    username?: string | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        return data; 
    }
}

export interface IUserDto {
    username?: string | null;
}

export class CostsOverviewDto implements ICostsOverviewDto {
    items1?: CostlyQuantitiesOverviewItem[] | null;
    items2?: CostlyQuantitiesOverviewItem[] | null;

    constructor(data?: ICostsOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(CostlyQuantitiesOverviewItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(CostlyQuantitiesOverviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostsOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostsOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICostsOverviewDto {
    items1?: CostlyQuantitiesOverviewItem[] | null;
    items2?: CostlyQuantitiesOverviewItem[] | null;
}

export class CostlyQuantitiesOverviewItem implements ICostlyQuantitiesOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergyInMonths?: number[] | null;
    reactiveEnergyInMonths?: number[] | null;
    peakDemandInMonths?: number[] | null;
    message?: string | null;

    constructor(data?: ICostlyQuantitiesOverviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["activeEnergyInMonths"])) {
                this.activeEnergyInMonths = [] as any;
                for (let item of _data["activeEnergyInMonths"])
                    this.activeEnergyInMonths!.push(item);
            }
            if (Array.isArray(_data["reactiveEnergyInMonths"])) {
                this.reactiveEnergyInMonths = [] as any;
                for (let item of _data["reactiveEnergyInMonths"])
                    this.reactiveEnergyInMonths!.push(item);
            }
            if (Array.isArray(_data["peakDemandInMonths"])) {
                this.peakDemandInMonths = [] as any;
                for (let item of _data["peakDemandInMonths"])
                    this.peakDemandInMonths!.push(item);
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): CostlyQuantitiesOverviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new CostlyQuantitiesOverviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.activeEnergyInMonths)) {
            data["activeEnergyInMonths"] = [];
            for (let item of this.activeEnergyInMonths)
                data["activeEnergyInMonths"].push(item);
        }
        if (Array.isArray(this.reactiveEnergyInMonths)) {
            data["reactiveEnergyInMonths"] = [];
            for (let item of this.reactiveEnergyInMonths)
                data["reactiveEnergyInMonths"].push(item);
        }
        if (Array.isArray(this.peakDemandInMonths)) {
            data["peakDemandInMonths"] = [];
            for (let item of this.peakDemandInMonths)
                data["peakDemandInMonths"].push(item);
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data; 
    }
}

export interface ICostlyQuantitiesOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergyInMonths?: number[] | null;
    reactiveEnergyInMonths?: number[] | null;
    peakDemandInMonths?: number[] | null;
    message?: string | null;
}

export class CostsDetailDto implements ICostsDetailDto {
    groupName?: string | null;
    items1?: CostlyQuantitiesDetailItem[] | null;
    items2?: CostlyQuantitiesDetailItem[] | null;

    constructor(data?: ICostsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(CostlyQuantitiesDetailItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(CostlyQuantitiesDetailItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICostsDetailDto {
    groupName?: string | null;
    items1?: CostlyQuantitiesDetailItem[] | null;
    items2?: CostlyQuantitiesDetailItem[] | null;
}

export class CostlyQuantitiesDetailItem implements ICostlyQuantitiesDetailItem {
    year?: number;
    month?: number;
    activeEnergy?: number;
    reactiveEnergy?: number;
    peakDemand?: number;

    constructor(data?: ICostlyQuantitiesDetailItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"] !== undefined ? _data["year"] : <any>null;
            this.month = _data["month"] !== undefined ? _data["month"] : <any>null;
            this.activeEnergy = _data["activeEnergy"] !== undefined ? _data["activeEnergy"] : <any>null;
            this.reactiveEnergy = _data["reactiveEnergy"] !== undefined ? _data["reactiveEnergy"] : <any>null;
            this.peakDemand = _data["peakDemand"] !== undefined ? _data["peakDemand"] : <any>null;
        }
    }

    static fromJS(data: any): CostlyQuantitiesDetailItem {
        data = typeof data === 'object' ? data : {};
        let result = new CostlyQuantitiesDetailItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["activeEnergy"] = this.activeEnergy !== undefined ? this.activeEnergy : <any>null;
        data["reactiveEnergy"] = this.reactiveEnergy !== undefined ? this.reactiveEnergy : <any>null;
        data["peakDemand"] = this.peakDemand !== undefined ? this.peakDemand : <any>null;
        return data; 
    }
}

export interface ICostlyQuantitiesDetailItem {
    year?: number;
    month?: number;
    activeEnergy?: number;
    reactiveEnergy?: number;
    peakDemand?: number;
}

export class DataSourceInfoDto implements IDataSourceInfoDto {
    name?: string | null;

    constructor(data?: IDataSourceInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DataSourceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDataSourceInfoDto {
    name?: string | null;
}

export class OpenDataSourceCommand implements IOpenDataSourceCommand {
    tenant?: TenantDto | null;

    constructor(data?: IOpenDataSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant = _data["tenant"] ? TenantDto.fromJS(_data["tenant"]) : <any>null;
        }
    }

    static fromJS(data: any): OpenDataSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OpenDataSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>null;
        return data; 
    }
}

export interface IOpenDataSourceCommand {
    tenant?: TenantDto | null;
}

export class TenantDto implements ITenantDto {
    dataSourceType?: DataSourceType;
    dbConnectionParams?: DBConnectionParams | null;
    ceaFileName?: string | null;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataSourceType = _data["dataSourceType"] !== undefined ? _data["dataSourceType"] : <any>null;
            this.dbConnectionParams = _data["dbConnectionParams"] ? DBConnectionParams.fromJS(_data["dbConnectionParams"]) : <any>null;
            this.ceaFileName = _data["ceaFileName"] !== undefined ? _data["ceaFileName"] : <any>null;
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataSourceType"] = this.dataSourceType !== undefined ? this.dataSourceType : <any>null;
        data["dbConnectionParams"] = this.dbConnectionParams ? this.dbConnectionParams.toJSON() : <any>null;
        data["ceaFileName"] = this.ceaFileName !== undefined ? this.ceaFileName : <any>null;
        return data; 
    }
}

export interface ITenantDto {
    dataSourceType?: DataSourceType;
    dbConnectionParams?: DBConnectionParams | null;
    ceaFileName?: string | null;
}

export enum DataSourceType {
    DB = 0,
    File = 1,
}

export class DBConnectionParams implements IDBConnectionParams {
    server?: string | null;
    dbName?: string | null;
    username?: string | null;
    password?: string | null;

    constructor(data?: IDBConnectionParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.server = _data["server"] !== undefined ? _data["server"] : <any>null;
            this.dbName = _data["dbName"] !== undefined ? _data["dbName"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): DBConnectionParams {
        data = typeof data === 'object' ? data : {};
        let result = new DBConnectionParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["server"] = this.server !== undefined ? this.server : <any>null;
        data["dbName"] = this.dbName !== undefined ? this.dbName : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IDBConnectionParams {
    server?: string | null;
    dbName?: string | null;
    username?: string | null;
    password?: string | null;
}

export class SmpMeasNameDBDto implements ISmpMeasNameDBDto {
    id?: number;
    measName?: string | null;
    userName?: string | null;
    measurementPathNoAlias?: string | null;
    measurementPath?: string | null;
    recordAndObject?: string | null;
    measurementPathFull?: string | null;
    alias?: string | null;

    constructor(data?: ISmpMeasNameDBDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.measName = _data["measName"] !== undefined ? _data["measName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.measurementPathNoAlias = _data["measurementPathNoAlias"] !== undefined ? _data["measurementPathNoAlias"] : <any>null;
            this.measurementPath = _data["measurementPath"] !== undefined ? _data["measurementPath"] : <any>null;
            this.recordAndObject = _data["recordAndObject"] !== undefined ? _data["recordAndObject"] : <any>null;
            this.measurementPathFull = _data["measurementPathFull"] !== undefined ? _data["measurementPathFull"] : <any>null;
            this.alias = _data["alias"] !== undefined ? _data["alias"] : <any>null;
        }
    }

    static fromJS(data: any): SmpMeasNameDBDto {
        data = typeof data === 'object' ? data : {};
        let result = new SmpMeasNameDBDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["measName"] = this.measName !== undefined ? this.measName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["measurementPathNoAlias"] = this.measurementPathNoAlias !== undefined ? this.measurementPathNoAlias : <any>null;
        data["measurementPath"] = this.measurementPath !== undefined ? this.measurementPath : <any>null;
        data["recordAndObject"] = this.recordAndObject !== undefined ? this.recordAndObject : <any>null;
        data["measurementPathFull"] = this.measurementPathFull !== undefined ? this.measurementPathFull : <any>null;
        data["alias"] = this.alias !== undefined ? this.alias : <any>null;
        return data; 
    }
}

export interface ISmpMeasNameDBDto {
    id?: number;
    measName?: string | null;
    userName?: string | null;
    measurementPathNoAlias?: string | null;
    measurementPath?: string | null;
    recordAndObject?: string | null;
    measurementPathFull?: string | null;
    alias?: string | null;
}

export class GroupInfoDto implements IGroupInfoDto {
    id?: string | null;
    name?: string | null;
    archives?: ArchiveInfoDto[] | null;
    subgroups?: GroupInfoDto[] | null;

    constructor(data?: IGroupInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["archives"])) {
                this.archives = [] as any;
                for (let item of _data["archives"])
                    this.archives!.push(ArchiveInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["subgroups"])) {
                this.subgroups = [] as any;
                for (let item of _data["subgroups"])
                    this.subgroups!.push(GroupInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.archives)) {
            data["archives"] = [];
            for (let item of this.archives)
                data["archives"].push(item.toJSON());
        }
        if (Array.isArray(this.subgroups)) {
            data["subgroups"] = [];
            for (let item of this.subgroups)
                data["subgroups"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGroupInfoDto {
    id?: string | null;
    name?: string | null;
    archives?: ArchiveInfoDto[] | null;
    subgroups?: GroupInfoDto[] | null;
}

export class ArchiveInfoDto implements IArchiveInfoDto {
    arch?: number;
    count?: number;
    range?: DateRangeDto | null;
    intervals?: DateRangeDto[] | null;
    name?: string | null;

    constructor(data?: IArchiveInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.arch = _data["arch"] !== undefined ? _data["arch"] : <any>null;
            this.count = _data["count"] !== undefined ? _data["count"] : <any>null;
            this.range = _data["range"] ? DateRangeDto.fromJS(_data["range"]) : <any>null;
            if (Array.isArray(_data["intervals"])) {
                this.intervals = [] as any;
                for (let item of _data["intervals"])
                    this.intervals!.push(DateRangeDto.fromJS(item));
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ArchiveInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arch"] = this.arch !== undefined ? this.arch : <any>null;
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["range"] = this.range ? this.range.toJSON() : <any>null;
        if (Array.isArray(this.intervals)) {
            data["intervals"] = [];
            for (let item of this.intervals)
                data["intervals"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IArchiveInfoDto {
    arch?: number;
    count?: number;
    range?: DateRangeDto | null;
    intervals?: DateRangeDto[] | null;
    name?: string | null;
}

export class DateRangeDto implements IDateRangeDto {
    dateMin?: Date;
    dateMax?: Date;

    constructor(data?: IDateRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateMin = _data["dateMin"] ? new Date(_data["dateMin"].toString()) : <any>null;
            this.dateMax = _data["dateMax"] ? new Date(_data["dateMax"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): DateRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateMin"] = this.dateMin ? this.dateMin.toISOString() : <any>null;
        data["dateMax"] = this.dateMax ? this.dateMax.toISOString() : <any>null;
        return data; 
    }
}

export interface IDateRangeDto {
    dateMin?: Date;
    dateMax?: Date;
}

export enum ArchiveInfoType {
    None = 0,
    CountOnly = 1,
    DateRange = 2,
    All = 3,
}

export class PeakDemandOverviewDto implements IPeakDemandOverviewDto {
    items1?: PeakDemandOverviewItem[] | null;
    items2?: PeakDemandOverviewItem[] | null;

    constructor(data?: IPeakDemandOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(PeakDemandOverviewItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(PeakDemandOverviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PeakDemandOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeakDemandOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPeakDemandOverviewDto {
    items1?: PeakDemandOverviewItem[] | null;
    items2?: PeakDemandOverviewItem[] | null;
}

export class PeakDemandOverviewItem implements IPeakDemandOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    peakDemands?: PeakDemandItemDto[] | null;

    constructor(data?: IPeakDemandOverviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["peakDemands"])) {
                this.peakDemands = [] as any;
                for (let item of _data["peakDemands"])
                    this.peakDemands!.push(PeakDemandItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PeakDemandOverviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new PeakDemandOverviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.peakDemands)) {
            data["peakDemands"] = [];
            for (let item of this.peakDemands)
                data["peakDemands"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPeakDemandOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    peakDemands?: PeakDemandItemDto[] | null;
}

export class PeakDemandItemDto implements IPeakDemandItemDto {
    start?: Date;
    value?: number;

    constructor(data?: IPeakDemandItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PeakDemandItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeakDemandItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IPeakDemandItemDto {
    start?: Date;
    value?: number;
}

export class PeakDemandDetailDto implements IPeakDemandDetailDto {
    demandSeries1?: DemandSeriesDto | null;
    demandSeries2?: DemandSeriesDto | null;

    constructor(data?: IPeakDemandDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.demandSeries1 = _data["demandSeries1"] ? DemandSeriesDto.fromJS(_data["demandSeries1"]) : <any>null;
            this.demandSeries2 = _data["demandSeries2"] ? DemandSeriesDto.fromJS(_data["demandSeries2"]) : <any>null;
        }
    }

    static fromJS(data: any): PeakDemandDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeakDemandDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["demandSeries1"] = this.demandSeries1 ? this.demandSeries1.toJSON() : <any>null;
        data["demandSeries2"] = this.demandSeries2 ? this.demandSeries2.toJSON() : <any>null;
        return data; 
    }
}

export interface IPeakDemandDetailDto {
    demandSeries1?: DemandSeriesDto | null;
    demandSeries2?: DemandSeriesDto | null;
}

export class DemandSeriesDto implements IDemandSeriesDto {
    timeRange?: IntervalDto | null;
    timeStep?: number;
    valuesMain?: number[] | null;
    valuesL1?: number[] | null;
    valuesL2?: number[] | null;
    valuesL3?: number[] | null;

    constructor(data?: IDemandSeriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeRange = _data["timeRange"] ? IntervalDto.fromJS(_data["timeRange"]) : <any>null;
            this.timeStep = _data["timeStep"] !== undefined ? _data["timeStep"] : <any>null;
            if (Array.isArray(_data["valuesMain"])) {
                this.valuesMain = [] as any;
                for (let item of _data["valuesMain"])
                    this.valuesMain!.push(item);
            }
            if (Array.isArray(_data["valuesL1"])) {
                this.valuesL1 = [] as any;
                for (let item of _data["valuesL1"])
                    this.valuesL1!.push(item);
            }
            if (Array.isArray(_data["valuesL2"])) {
                this.valuesL2 = [] as any;
                for (let item of _data["valuesL2"])
                    this.valuesL2!.push(item);
            }
            if (Array.isArray(_data["valuesL3"])) {
                this.valuesL3 = [] as any;
                for (let item of _data["valuesL3"])
                    this.valuesL3!.push(item);
            }
        }
    }

    static fromJS(data: any): DemandSeriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemandSeriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeRange"] = this.timeRange ? this.timeRange.toJSON() : <any>null;
        data["timeStep"] = this.timeStep !== undefined ? this.timeStep : <any>null;
        if (Array.isArray(this.valuesMain)) {
            data["valuesMain"] = [];
            for (let item of this.valuesMain)
                data["valuesMain"].push(item);
        }
        if (Array.isArray(this.valuesL1)) {
            data["valuesL1"] = [];
            for (let item of this.valuesL1)
                data["valuesL1"].push(item);
        }
        if (Array.isArray(this.valuesL2)) {
            data["valuesL2"] = [];
            for (let item of this.valuesL2)
                data["valuesL2"].push(item);
        }
        if (Array.isArray(this.valuesL3)) {
            data["valuesL3"] = [];
            for (let item of this.valuesL3)
                data["valuesL3"].push(item);
        }
        return data; 
    }
}

export interface IDemandSeriesDto {
    timeRange?: IntervalDto | null;
    timeStep?: number;
    valuesMain?: number[] | null;
    valuesL1?: number[] | null;
    valuesL2?: number[] | null;
    valuesL3?: number[] | null;
}

export class IntervalDto implements IIntervalDto {
    start?: Date | null;
    end?: Date | null;
    isInfinite?: boolean | null;

    constructor(data?: IIntervalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>null;
            this.isInfinite = _data["isInfinite"] !== undefined ? _data["isInfinite"] : <any>null;
        }
    }

    static fromJS(data: any): IntervalDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntervalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["end"] = this.end ? this.end.toISOString() : <any>null;
        data["isInfinite"] = this.isInfinite !== undefined ? this.isInfinite : <any>null;
        return data; 
    }
}

export interface IIntervalDto {
    start?: Date | null;
    end?: Date | null;
    isInfinite?: boolean | null;
}

export enum DemandAggregation {
    None = 1,
    OneHour = 4,
    SixHours = 24,
    TwelveHours = 48,
    OneDay = 96,
    OneWeek = 672,
}

export class PowerFactorOverviewDto implements IPowerFactorOverviewDto {
    items1?: PowerFactorOverviewItem[] | null;
    items2?: PowerFactorOverviewItem[] | null;

    constructor(data?: IPowerFactorOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(PowerFactorOverviewItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(PowerFactorOverviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PowerFactorOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPowerFactorOverviewDto {
    items1?: PowerFactorOverviewItem[] | null;
    items2?: PowerFactorOverviewItem[] | null;
}

export class PowerFactorOverviewItem implements IPowerFactorOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergy?: number;
    reactiveEnergyL?: number;
    reactiveEnergyC?: number;
    cosFi?: number;
    interval?: Interval | null;

    constructor(data?: IPowerFactorOverviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            this.activeEnergy = _data["activeEnergy"] !== undefined ? _data["activeEnergy"] : <any>null;
            this.reactiveEnergyL = _data["reactiveEnergyL"] !== undefined ? _data["reactiveEnergyL"] : <any>null;
            this.reactiveEnergyC = _data["reactiveEnergyC"] !== undefined ? _data["reactiveEnergyC"] : <any>null;
            this.cosFi = _data["cosFi"] !== undefined ? _data["cosFi"] : <any>null;
            this.interval = _data["interval"] ? Interval.fromJS(_data["interval"]) : <any>null;
        }
    }

    static fromJS(data: any): PowerFactorOverviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorOverviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        data["activeEnergy"] = this.activeEnergy !== undefined ? this.activeEnergy : <any>null;
        data["reactiveEnergyL"] = this.reactiveEnergyL !== undefined ? this.reactiveEnergyL : <any>null;
        data["reactiveEnergyC"] = this.reactiveEnergyC !== undefined ? this.reactiveEnergyC : <any>null;
        data["cosFi"] = this.cosFi !== undefined ? this.cosFi : <any>null;
        data["interval"] = this.interval ? this.interval.toJSON() : <any>null;
        return data; 
    }
}

export interface IPowerFactorOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergy?: number;
    reactiveEnergyL?: number;
    reactiveEnergyC?: number;
    cosFi?: number;
    interval?: Interval | null;
}

export class Interval implements IInterval {
    start?: Date | null;
    end?: Date | null;

    constructor(data?: IInterval) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Interval {
        data = typeof data === 'object' ? data : {};
        let result = new Interval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["end"] = this.end ? this.end.toISOString() : <any>null;
        return data; 
    }
}

export interface IInterval {
    start?: Date | null;
    end?: Date | null;
}

export class PowerFactorDistributionDto implements IPowerFactorDistributionDto {
    groupName?: string | null;
    distribution1?: PowerFactorDistributionItem[] | null;
    distribution2?: PowerFactorDistributionItem[] | null;
    interval1?: IntervalDto | null;
    interval2?: IntervalDto | null;

    constructor(data?: IPowerFactorDistributionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["distribution1"])) {
                this.distribution1 = [] as any;
                for (let item of _data["distribution1"])
                    this.distribution1!.push(PowerFactorDistributionItem.fromJS(item));
            }
            if (Array.isArray(_data["distribution2"])) {
                this.distribution2 = [] as any;
                for (let item of _data["distribution2"])
                    this.distribution2!.push(PowerFactorDistributionItem.fromJS(item));
            }
            this.interval1 = _data["interval1"] ? IntervalDto.fromJS(_data["interval1"]) : <any>null;
            this.interval2 = _data["interval2"] ? IntervalDto.fromJS(_data["interval2"]) : <any>null;
        }
    }

    static fromJS(data: any): PowerFactorDistributionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorDistributionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.distribution1)) {
            data["distribution1"] = [];
            for (let item of this.distribution1)
                data["distribution1"].push(item.toJSON());
        }
        if (Array.isArray(this.distribution2)) {
            data["distribution2"] = [];
            for (let item of this.distribution2)
                data["distribution2"].push(item.toJSON());
        }
        data["interval1"] = this.interval1 ? this.interval1.toJSON() : <any>null;
        data["interval2"] = this.interval2 ? this.interval2.toJSON() : <any>null;
        return data; 
    }
}

export interface IPowerFactorDistributionDto {
    groupName?: string | null;
    distribution1?: PowerFactorDistributionItem[] | null;
    distribution2?: PowerFactorDistributionItem[] | null;
    interval1?: IntervalDto | null;
    interval2?: IntervalDto | null;
}

export class PowerFactorDistributionItem implements IPowerFactorDistributionItem {
    range?: string | null;
    valueMain?: number | null;
    valueL1?: number | null;
    valueL2?: number | null;
    valueL3?: number | null;

    constructor(data?: IPowerFactorDistributionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.range = _data["range"] !== undefined ? _data["range"] : <any>null;
            this.valueMain = _data["valueMain"] !== undefined ? _data["valueMain"] : <any>null;
            this.valueL1 = _data["valueL1"] !== undefined ? _data["valueL1"] : <any>null;
            this.valueL2 = _data["valueL2"] !== undefined ? _data["valueL2"] : <any>null;
            this.valueL3 = _data["valueL3"] !== undefined ? _data["valueL3"] : <any>null;
        }
    }

    static fromJS(data: any): PowerFactorDistributionItem {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorDistributionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["range"] = this.range !== undefined ? this.range : <any>null;
        data["valueMain"] = this.valueMain !== undefined ? this.valueMain : <any>null;
        data["valueL1"] = this.valueL1 !== undefined ? this.valueL1 : <any>null;
        data["valueL2"] = this.valueL2 !== undefined ? this.valueL2 : <any>null;
        data["valueL3"] = this.valueL3 !== undefined ? this.valueL3 : <any>null;
        return data; 
    }
}

export interface IPowerFactorDistributionItem {
    range?: string | null;
    valueMain?: number | null;
    valueL1?: number | null;
    valueL2?: number | null;
    valueL3?: number | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}