/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.2.0 (NJsonSchema v10.3.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICostsClient {
    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined): Observable<CostsOverviewDto>;
    getDetail(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, groupId: string | null | undefined): Observable<CostsDetailDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CostsClient implements ICostsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined): Observable<CostsOverviewDto> {
        let url_ = this.baseUrl + "/api/Costs/overview?";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOverview(<any>response_);
                } catch (e) {
                    return <Observable<CostsOverviewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CostsOverviewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOverview(response: HttpResponseBase): Observable<CostsOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostsOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostsOverviewDto>(<any>null);
    }

    getDetail(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, groupId: string | null | undefined): Observable<CostsDetailDto> {
        let url_ = this.baseUrl + "/api/Costs/detail?";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<CostsDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CostsDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CostsDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostsDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostsDetailDto>(<any>null);
    }
}

export interface IGroupsClient {
    getUserGroups(): Observable<UserGroupsDto>;
    getUserGroupTree(): Observable<GroupTreeNodeDto>;
}

@Injectable({
    providedIn: 'root'
})
export class GroupsClient implements IGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserGroups(): Observable<UserGroupsDto> {
        let url_ = this.baseUrl + "/api/Groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroups(<any>response_);
                } catch (e) {
                    return <Observable<UserGroupsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserGroupsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroups(response: HttpResponseBase): Observable<UserGroupsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroupsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserGroupsDto>(<any>null);
    }

    getUserGroupTree(): Observable<GroupTreeNodeDto> {
        let url_ = this.baseUrl + "/api/Groups/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroupTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroupTree(<any>response_);
                } catch (e) {
                    return <Observable<GroupTreeNodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupTreeNodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroupTree(response: HttpResponseBase): Observable<GroupTreeNodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupTreeNodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupTreeNodeDto>(<any>null);
    }
}

export interface IPowerFactorClient {
    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, groupIds: string[] | null | undefined): Observable<PowerFactorOverviewDto>;
    getDistribution(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, phases_Main: boolean | null | undefined, phases_L1: boolean | null | undefined, phases_L2: boolean | null | undefined, phases_L3: boolean | null | undefined): Observable<PowerFactorDistributionDto>;
}

@Injectable({
    providedIn: 'root'
})
export class PowerFactorClient implements IPowerFactorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOverview(interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, groupIds: string[] | null | undefined): Observable<PowerFactorOverviewDto> {
        let url_ = this.baseUrl + "/api/PowerFactor/overview?";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (groupIds !== undefined && groupIds !== null)
            groupIds && groupIds.forEach(item => { url_ += "GroupIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOverview(<any>response_);
                } catch (e) {
                    return <Observable<PowerFactorOverviewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerFactorOverviewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOverview(response: HttpResponseBase): Observable<PowerFactorOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PowerFactorOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerFactorOverviewDto>(<any>null);
    }

    getDistribution(groupId: string | null | undefined, interval1_Start: Date | null | undefined, interval1_End: Date | null | undefined, interval1_IsInfinite: boolean | null | undefined, interval2_Start: Date | null | undefined, interval2_End: Date | null | undefined, interval2_IsInfinite: boolean | null | undefined, phases_Main: boolean | null | undefined, phases_L1: boolean | null | undefined, phases_L2: boolean | null | undefined, phases_L3: boolean | null | undefined): Observable<PowerFactorDistributionDto> {
        let url_ = this.baseUrl + "/api/PowerFactor/distribution?";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (interval1_Start !== undefined && interval1_Start !== null)
            url_ += "Interval1.Start=" + encodeURIComponent(interval1_Start ? "" + interval1_Start.toJSON() : "") + "&";
        if (interval1_End !== undefined && interval1_End !== null)
            url_ += "Interval1.End=" + encodeURIComponent(interval1_End ? "" + interval1_End.toJSON() : "") + "&";
        if (interval1_IsInfinite !== undefined && interval1_IsInfinite !== null)
            url_ += "Interval1.IsInfinite=" + encodeURIComponent("" + interval1_IsInfinite) + "&";
        if (interval2_Start !== undefined && interval2_Start !== null)
            url_ += "Interval2.Start=" + encodeURIComponent(interval2_Start ? "" + interval2_Start.toJSON() : "") + "&";
        if (interval2_End !== undefined && interval2_End !== null)
            url_ += "Interval2.End=" + encodeURIComponent(interval2_End ? "" + interval2_End.toJSON() : "") + "&";
        if (interval2_IsInfinite !== undefined && interval2_IsInfinite !== null)
            url_ += "Interval2.IsInfinite=" + encodeURIComponent("" + interval2_IsInfinite) + "&";
        if (phases_Main !== undefined && phases_Main !== null)
            url_ += "Phases.Main=" + encodeURIComponent("" + phases_Main) + "&";
        if (phases_L1 !== undefined && phases_L1 !== null)
            url_ += "Phases.L1=" + encodeURIComponent("" + phases_L1) + "&";
        if (phases_L2 !== undefined && phases_L2 !== null)
            url_ += "Phases.L2=" + encodeURIComponent("" + phases_L2) + "&";
        if (phases_L3 !== undefined && phases_L3 !== null)
            url_ += "Phases.L3=" + encodeURIComponent("" + phases_L3) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistribution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistribution(<any>response_);
                } catch (e) {
                    return <Observable<PowerFactorDistributionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerFactorDistributionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDistribution(response: HttpResponseBase): Observable<PowerFactorDistributionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PowerFactorDistributionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerFactorDistributionDto>(<any>null);
    }
}

export interface IQuantitiesClient {
    getQuantities(groupId: string | undefined, arch: number | undefined): Observable<QuantitiesDto>;
}

@Injectable({
    providedIn: 'root'
})
export class QuantitiesClient implements IQuantitiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getQuantities(groupId: string | undefined, arch: number | undefined): Observable<QuantitiesDto> {
        let url_ = this.baseUrl + "/api/Quantities?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (arch === null)
            throw new Error("The parameter 'arch' cannot be null.");
        else if (arch !== undefined)
            url_ += "arch=" + encodeURIComponent("" + arch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuantities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuantities(<any>response_);
                } catch (e) {
                    return <Observable<QuantitiesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuantitiesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuantities(response: HttpResponseBase): Observable<QuantitiesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuantitiesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuantitiesDto>(<any>null);
    }
}

export interface ISeriesClient {
    getQuantity(groupId: string | undefined, arch: number | undefined, qty: string | null | undefined, aggMeth: AggregationMethod | undefined, aggInt: number | undefined): Observable<TimeSeriesDtoOfSingle>;
}

@Injectable({
    providedIn: 'root'
})
export class SeriesClient implements ISeriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getQuantity(groupId: string | undefined, arch: number | undefined, qty: string | null | undefined, aggMeth: AggregationMethod | undefined, aggInt: number | undefined): Observable<TimeSeriesDtoOfSingle> {
        let url_ = this.baseUrl + "/api/Series/quantity?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (arch === null)
            throw new Error("The parameter 'arch' cannot be null.");
        else if (arch !== undefined)
            url_ += "Arch=" + encodeURIComponent("" + arch) + "&";
        if (qty !== undefined && qty !== null)
            url_ += "Qty=" + encodeURIComponent("" + qty) + "&";
        if (aggMeth === null)
            throw new Error("The parameter 'aggMeth' cannot be null.");
        else if (aggMeth !== undefined)
            url_ += "AggMeth=" + encodeURIComponent("" + aggMeth) + "&";
        if (aggInt === null)
            throw new Error("The parameter 'aggInt' cannot be null.");
        else if (aggInt !== undefined)
            url_ += "AggInt=" + encodeURIComponent("" + aggInt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuantity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuantity(<any>response_);
                } catch (e) {
                    return <Observable<TimeSeriesDtoOfSingle>><any>_observableThrow(e);
                }
            } else
                return <Observable<TimeSeriesDtoOfSingle>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuantity(response: HttpResponseBase): Observable<TimeSeriesDtoOfSingle> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeSeriesDtoOfSingle.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimeSeriesDtoOfSingle>(<any>null);
    }
}

export class CostsOverviewDto implements ICostsOverviewDto {
    items1?: CostlyQuantitiesOverviewItem[] | null;
    items2?: CostlyQuantitiesOverviewItem[] | null;

    constructor(data?: ICostsOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(CostlyQuantitiesOverviewItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(CostlyQuantitiesOverviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostsOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostsOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICostsOverviewDto {
    items1?: CostlyQuantitiesOverviewItem[] | null;
    items2?: CostlyQuantitiesOverviewItem[] | null;
}

export class CostlyQuantitiesOverviewItem implements ICostlyQuantitiesOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergyInMonths?: number[] | null;
    reactiveEnergyInMonths?: number[] | null;
    peakDemandInMonths?: number[] | null;

    constructor(data?: ICostlyQuantitiesOverviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["activeEnergyInMonths"])) {
                this.activeEnergyInMonths = [] as any;
                for (let item of _data["activeEnergyInMonths"])
                    this.activeEnergyInMonths!.push(item);
            }
            if (Array.isArray(_data["reactiveEnergyInMonths"])) {
                this.reactiveEnergyInMonths = [] as any;
                for (let item of _data["reactiveEnergyInMonths"])
                    this.reactiveEnergyInMonths!.push(item);
            }
            if (Array.isArray(_data["peakDemandInMonths"])) {
                this.peakDemandInMonths = [] as any;
                for (let item of _data["peakDemandInMonths"])
                    this.peakDemandInMonths!.push(item);
            }
        }
    }

    static fromJS(data: any): CostlyQuantitiesOverviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new CostlyQuantitiesOverviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.activeEnergyInMonths)) {
            data["activeEnergyInMonths"] = [];
            for (let item of this.activeEnergyInMonths)
                data["activeEnergyInMonths"].push(item);
        }
        if (Array.isArray(this.reactiveEnergyInMonths)) {
            data["reactiveEnergyInMonths"] = [];
            for (let item of this.reactiveEnergyInMonths)
                data["reactiveEnergyInMonths"].push(item);
        }
        if (Array.isArray(this.peakDemandInMonths)) {
            data["peakDemandInMonths"] = [];
            for (let item of this.peakDemandInMonths)
                data["peakDemandInMonths"].push(item);
        }
        return data; 
    }
}

export interface ICostlyQuantitiesOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergyInMonths?: number[] | null;
    reactiveEnergyInMonths?: number[] | null;
    peakDemandInMonths?: number[] | null;
}

export class CostsDetailDto implements ICostsDetailDto {
    groupName?: string | null;
    items1?: CostlyQuantitiesDetailItem[] | null;
    items2?: CostlyQuantitiesDetailItem[] | null;

    constructor(data?: ICostsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(CostlyQuantitiesDetailItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(CostlyQuantitiesDetailItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICostsDetailDto {
    groupName?: string | null;
    items1?: CostlyQuantitiesDetailItem[] | null;
    items2?: CostlyQuantitiesDetailItem[] | null;
}

export class CostlyQuantitiesDetailItem implements ICostlyQuantitiesDetailItem {
    year?: number;
    month?: number;
    activeEnergy?: number;
    reactiveEnergy?: number;
    peakDemand?: number;

    constructor(data?: ICostlyQuantitiesDetailItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"] !== undefined ? _data["year"] : <any>null;
            this.month = _data["month"] !== undefined ? _data["month"] : <any>null;
            this.activeEnergy = _data["activeEnergy"] !== undefined ? _data["activeEnergy"] : <any>null;
            this.reactiveEnergy = _data["reactiveEnergy"] !== undefined ? _data["reactiveEnergy"] : <any>null;
            this.peakDemand = _data["peakDemand"] !== undefined ? _data["peakDemand"] : <any>null;
        }
    }

    static fromJS(data: any): CostlyQuantitiesDetailItem {
        data = typeof data === 'object' ? data : {};
        let result = new CostlyQuantitiesDetailItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["activeEnergy"] = this.activeEnergy !== undefined ? this.activeEnergy : <any>null;
        data["reactiveEnergy"] = this.reactiveEnergy !== undefined ? this.reactiveEnergy : <any>null;
        data["peakDemand"] = this.peakDemand !== undefined ? this.peakDemand : <any>null;
        return data; 
    }
}

export interface ICostlyQuantitiesDetailItem {
    year?: number;
    month?: number;
    activeEnergy?: number;
    reactiveEnergy?: number;
    peakDemand?: number;
}

export class UserGroupsDto implements IUserGroupsDto {
    groups?: GroupDto[] | null;

    constructor(data?: IUserGroupsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserGroupsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserGroupsDto {
    groups?: GroupDto[] | null;
}

export class GroupDto implements IGroupDto {
    id?: string;
    name?: string | null;

    constructor(data?: IGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IGroupDto {
    id?: string;
    name?: string | null;
}

export class GroupTreeNodeDto implements IGroupTreeNodeDto {
    group?: GroupDto | null;
    nodes?: GroupTreeNodeDto[] | null;

    constructor(data?: IGroupTreeNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"] ? GroupDto.fromJS(_data["group"]) : <any>null;
            if (Array.isArray(_data["nodes"])) {
                this.nodes = [] as any;
                for (let item of _data["nodes"])
                    this.nodes!.push(GroupTreeNodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupTreeNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTreeNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>null;
        if (Array.isArray(this.nodes)) {
            data["nodes"] = [];
            for (let item of this.nodes)
                data["nodes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGroupTreeNodeDto {
    group?: GroupDto | null;
    nodes?: GroupTreeNodeDto[] | null;
}

export class PowerFactorOverviewDto implements IPowerFactorOverviewDto {
    items1?: PowerFactorOverviewItem[] | null;
    items2?: PowerFactorOverviewItem[] | null;

    constructor(data?: IPowerFactorOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items1"])) {
                this.items1 = [] as any;
                for (let item of _data["items1"])
                    this.items1!.push(PowerFactorOverviewItem.fromJS(item));
            }
            if (Array.isArray(_data["items2"])) {
                this.items2 = [] as any;
                for (let item of _data["items2"])
                    this.items2!.push(PowerFactorOverviewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PowerFactorOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items1)) {
            data["items1"] = [];
            for (let item of this.items1)
                data["items1"].push(item.toJSON());
        }
        if (Array.isArray(this.items2)) {
            data["items2"] = [];
            for (let item of this.items2)
                data["items2"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPowerFactorOverviewDto {
    items1?: PowerFactorOverviewItem[] | null;
    items2?: PowerFactorOverviewItem[] | null;
}

export class PowerFactorOverviewItem implements IPowerFactorOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergy?: number;
    reactiveEnergyL?: number;
    reactiveEnergyC?: number;
    cosFi?: number;
    interval?: Interval | null;

    constructor(data?: IPowerFactorOverviewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            this.activeEnergy = _data["activeEnergy"] !== undefined ? _data["activeEnergy"] : <any>null;
            this.reactiveEnergyL = _data["reactiveEnergyL"] !== undefined ? _data["reactiveEnergyL"] : <any>null;
            this.reactiveEnergyC = _data["reactiveEnergyC"] !== undefined ? _data["reactiveEnergyC"] : <any>null;
            this.cosFi = _data["cosFi"] !== undefined ? _data["cosFi"] : <any>null;
            this.interval = _data["interval"] ? Interval.fromJS(_data["interval"]) : <any>null;
        }
    }

    static fromJS(data: any): PowerFactorOverviewItem {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorOverviewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        data["activeEnergy"] = this.activeEnergy !== undefined ? this.activeEnergy : <any>null;
        data["reactiveEnergyL"] = this.reactiveEnergyL !== undefined ? this.reactiveEnergyL : <any>null;
        data["reactiveEnergyC"] = this.reactiveEnergyC !== undefined ? this.reactiveEnergyC : <any>null;
        data["cosFi"] = this.cosFi !== undefined ? this.cosFi : <any>null;
        data["interval"] = this.interval ? this.interval.toJSON() : <any>null;
        return data; 
    }
}

export interface IPowerFactorOverviewItem {
    groupId?: string | null;
    groupName?: string | null;
    activeEnergy?: number;
    reactiveEnergyL?: number;
    reactiveEnergyC?: number;
    cosFi?: number;
    interval?: Interval | null;
}

export class Interval implements IInterval {
    start?: Date | null;
    end?: Date | null;

    constructor(data?: IInterval) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Interval {
        data = typeof data === 'object' ? data : {};
        let result = new Interval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["end"] = this.end ? this.end.toISOString() : <any>null;
        return data; 
    }
}

export interface IInterval {
    start?: Date | null;
    end?: Date | null;
}

export class PowerFactorDistributionDto implements IPowerFactorDistributionDto {
    groupName?: string | null;
    distribution1?: PowerFactorDistributionItem[] | null;
    distribution2?: PowerFactorDistributionItem[] | null;
    interval1?: IntervalDto | null;
    interval2?: IntervalDto | null;

    constructor(data?: IPowerFactorDistributionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            if (Array.isArray(_data["distribution1"])) {
                this.distribution1 = [] as any;
                for (let item of _data["distribution1"])
                    this.distribution1!.push(PowerFactorDistributionItem.fromJS(item));
            }
            if (Array.isArray(_data["distribution2"])) {
                this.distribution2 = [] as any;
                for (let item of _data["distribution2"])
                    this.distribution2!.push(PowerFactorDistributionItem.fromJS(item));
            }
            this.interval1 = _data["interval1"] ? IntervalDto.fromJS(_data["interval1"]) : <any>null;
            this.interval2 = _data["interval2"] ? IntervalDto.fromJS(_data["interval2"]) : <any>null;
        }
    }

    static fromJS(data: any): PowerFactorDistributionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorDistributionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        if (Array.isArray(this.distribution1)) {
            data["distribution1"] = [];
            for (let item of this.distribution1)
                data["distribution1"].push(item.toJSON());
        }
        if (Array.isArray(this.distribution2)) {
            data["distribution2"] = [];
            for (let item of this.distribution2)
                data["distribution2"].push(item.toJSON());
        }
        data["interval1"] = this.interval1 ? this.interval1.toJSON() : <any>null;
        data["interval2"] = this.interval2 ? this.interval2.toJSON() : <any>null;
        return data; 
    }
}

export interface IPowerFactorDistributionDto {
    groupName?: string | null;
    distribution1?: PowerFactorDistributionItem[] | null;
    distribution2?: PowerFactorDistributionItem[] | null;
    interval1?: IntervalDto | null;
    interval2?: IntervalDto | null;
}

export class PowerFactorDistributionItem implements IPowerFactorDistributionItem {
    range?: string | null;
    valueMain?: number | null;
    valueL1?: number | null;
    valueL2?: number | null;
    valueL3?: number | null;

    constructor(data?: IPowerFactorDistributionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.range = _data["range"] !== undefined ? _data["range"] : <any>null;
            this.valueMain = _data["valueMain"] !== undefined ? _data["valueMain"] : <any>null;
            this.valueL1 = _data["valueL1"] !== undefined ? _data["valueL1"] : <any>null;
            this.valueL2 = _data["valueL2"] !== undefined ? _data["valueL2"] : <any>null;
            this.valueL3 = _data["valueL3"] !== undefined ? _data["valueL3"] : <any>null;
        }
    }

    static fromJS(data: any): PowerFactorDistributionItem {
        data = typeof data === 'object' ? data : {};
        let result = new PowerFactorDistributionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["range"] = this.range !== undefined ? this.range : <any>null;
        data["valueMain"] = this.valueMain !== undefined ? this.valueMain : <any>null;
        data["valueL1"] = this.valueL1 !== undefined ? this.valueL1 : <any>null;
        data["valueL2"] = this.valueL2 !== undefined ? this.valueL2 : <any>null;
        data["valueL3"] = this.valueL3 !== undefined ? this.valueL3 : <any>null;
        return data; 
    }
}

export interface IPowerFactorDistributionItem {
    range?: string | null;
    valueMain?: number | null;
    valueL1?: number | null;
    valueL2?: number | null;
    valueL3?: number | null;
}

export class IntervalDto implements IIntervalDto {
    start?: Date | null;
    end?: Date | null;
    isInfinite?: boolean | null;

    constructor(data?: IIntervalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>null;
            this.isInfinite = _data["isInfinite"] !== undefined ? _data["isInfinite"] : <any>null;
        }
    }

    static fromJS(data: any): IntervalDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntervalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["end"] = this.end ? this.end.toISOString() : <any>null;
        data["isInfinite"] = this.isInfinite !== undefined ? this.isInfinite : <any>null;
        return data; 
    }
}

export interface IIntervalDto {
    start?: Date | null;
    end?: Date | null;
    isInfinite?: boolean | null;
}

export class QuantitiesDto implements IQuantitiesDto {
    list?: QuantityDto[] | null;

    constructor(data?: IQuantitiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(QuantityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuantitiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuantitiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuantitiesDto {
    list?: QuantityDto[] | null;
}

export class QuantityDto implements IQuantityDto {
    propName?: string | null;
    unit?: string | null;
    returnType?: string | null;
    prop?: string | null;
    value?: any | null;

    constructor(data?: IQuantityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propName = _data["propName"] !== undefined ? _data["propName"] : <any>null;
            this.unit = _data["unit"] !== undefined ? _data["unit"] : <any>null;
            this.returnType = _data["returnType"] !== undefined ? _data["returnType"] : <any>null;
            this.prop = _data["prop"] !== undefined ? _data["prop"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): QuantityDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuantityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propName"] = this.propName !== undefined ? this.propName : <any>null;
        data["unit"] = this.unit !== undefined ? this.unit : <any>null;
        data["returnType"] = this.returnType !== undefined ? this.returnType : <any>null;
        data["prop"] = this.prop !== undefined ? this.prop : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IQuantityDto {
    propName?: string | null;
    unit?: string | null;
    returnType?: string | null;
    prop?: string | null;
    value?: any | null;
}

export class TimeSeriesDtoOfSingle implements ITimeSeriesDtoOfSingle {
    entries?: TupleOfDateTimeAndSingle[] | null;

    constructor(data?: ITimeSeriesDtoOfSingle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(TupleOfDateTimeAndSingle.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeSeriesDtoOfSingle {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesDtoOfSingle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITimeSeriesDtoOfSingle {
    entries?: TupleOfDateTimeAndSingle[] | null;
}

export class TupleOfDateTimeAndSingle implements ITupleOfDateTimeAndSingle {
    item1?: Date;
    item2?: number;

    constructor(data?: ITupleOfDateTimeAndSingle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"] ? new Date(_data["item1"].toString()) : <any>null;
            this.item2 = _data["item2"] !== undefined ? _data["item2"] : <any>null;
        }
    }

    static fromJS(data: any): TupleOfDateTimeAndSingle {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfDateTimeAndSingle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1 ? this.item1.toISOString() : <any>null;
        data["item2"] = this.item2 !== undefined ? this.item2 : <any>null;
        return data; 
    }
}

export interface ITupleOfDateTimeAndSingle {
    item1?: Date;
    item2?: number;
}

export enum AggregationMethod {
    Min = 0,
    Max = 1,
    Avg = 2,
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}